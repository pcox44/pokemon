<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Pokemon - Gotta Catch Em All</title>
<style>
body { margin:0; font-family:sans-serif; background:#111; color:white; overflow:hidden; }
#ui {
  position:fixed; top:10px; left:10px; background:rgba(0,0,0,0.8);
  padding:10px; border-radius:6px; z-index:10;
}
label { display:block; margin:5px 0; }
input[type=number] { width:60px; }
button { margin-top:5px; padding:5px 10px; cursor:pointer; background:#333; color:white; border:none; border-radius:4px; }
canvas { display:block; }
</style>
</head>
<body>
<div id="ui">
  <label>Number of Pokémon (1–151): <input type="number" id="nPokemon" value="9" min="1" max="151"></label>
  <label>Number of Simulations: <input type="number" id="nTrials" value="5"></label>
  <button id="startBtn">Start Simulation</button>
  <button id="resetBtn">Reset</button>
</div>

<canvas id="canvas"></canvas>

<script>
const spriteBase = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/';
const nSprites = 151;
const sprites = [];

for (let i = 1; i <= nSprites; i++) {
  const img = new Image();
  img.src = spriteBase + i + '.png';
  sprites.push(img);
}

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width, height;
function resizeCanvas() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let nPokemon = 9, nTrials = 5;
let trialIndex = 0;
let picks = 0;
let collected = new Set();
let allTrials = [];
let pokemonCounts = Array(nSprites).fill(0);

function harmonic(n) { let sum = 0; for (let i = 1; i <= n; i++) sum += 1 / i; return sum; }

function init() {
  nPokemon = Math.min(Math.max(parseInt(document.getElementById('nPokemon').value) || 9, 1), 151);
  nTrials = parseInt(document.getElementById('nTrials').value) || 5;
  trialIndex = 0; picks = 0; collected = new Set(); allTrials = [];
  cancelAnimationFrame(animationId);
  if (nTrials <= 10) {
    pokemonCounts = Array(nSprites).fill(0); // reset counts for small simulations
  }
  drawBase();
}

function pickPokemon() {
  const c = Math.floor(Math.random() * nPokemon);
  collected.add(c); picks++;
  pokemonCounts[c]++;
}

function drawBase() {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#222'; ctx.fillRect(0, 0, width, height);
  drawHistogram();
  drawInfo();
  drawPokemonSlots();
}

function drawPokemonSlots() {
  const margin = 20;
  const maxSlotWidth = 80;
  const maxColumns = 19; // <-- change to 16
  const columns = Math.min(nPokemon, maxColumns);
  const slotWidth = Math.min((width - 2 * margin) / columns, maxSlotWidth);
  const rows = Math.ceil(nPokemon / columns);

  for (let i = 0; i < nPokemon; i++) {
    const row = Math.floor(i / columns);
    const col = i % columns;
    const xPos = width - margin - (columns - col) * slotWidth;
    const yPos = margin + row * (slotWidth + 5);

    // draw slot
    ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
    ctx.strokeRect(xPos, yPos, slotWidth, slotWidth);

    // draw Pokémon if collected
    if (collected.has(i) || (nTrials > 10 && pokemonCounts[i] > 0)) {
      const img = sprites[i];
      if (img.complete) {
        ctx.drawImage(img, xPos, yPos, slotWidth, slotWidth);
      }
    }

    // draw count in bottom-right corner
    if (pokemonCounts[i] > 0) {
      ctx.fillStyle = 'white';
      ctx.font = `${Math.floor(slotWidth / 5)}px sans-serif`;
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      ctx.fillText(pokemonCounts[i], xPos + slotWidth - 2, yPos + slotWidth - 2);
    }
  }
}

function drawInfo() {
  const avg = (allTrials.reduce((a, b) => a + b, 0) + picks) / (allTrials.length + (picks > 0 ? 1 : 0));
  const expected = nPokemon * harmonic(nPokemon);
  const xShift = 150; // same shift as histogram
  const yShift = 100;  // move stats up by 50 pixels
  ctx.fillStyle = 'white'; 
  ctx.font = '14px sans-serif';
  ctx.fillText(`Trial: ${trialIndex + 1} / ${nTrials}`, 10 + xShift, height - 140 - yShift);
  ctx.fillText(`Picks this trial: ${picks}`, 10 + xShift, height - 120 - yShift);
  ctx.fillText(`Running Avg Picks: ${avg.toFixed(2)}`, 10 + xShift, height - 100 - yShift);
  ctx.fillText(`Expected Picks: ${expected.toFixed(2)}`, 10 + xShift, height - 80 - yShift);
  ctx.fillText(`Difference: ${(avg - expected).toFixed(2)}`, 10 + xShift, height - 60 - yShift);
}

function drawHistogram() {
  const margin = 20;
  const histHeight = 100;
  const histY = height - 150;
  const maxPick = Math.max(...allTrials, picks);
  const bins = Math.ceil(maxPick);
  const binWidth = (width - 2 * margin) / bins;
  const counts = Array(bins + 1).fill(0);
  for (let val of allTrials) counts[val]++;
  counts[picks]++;
  const maxCount = Math.max(...counts);

  // >>> SHIFT HISTOGRAM 60 PX TO THE RIGHT <<<
  const xShift = 60;

  for (let i = 0; i < counts.length; i++) {
    const h = counts[i] / maxCount * histHeight;
    ctx.fillStyle = `hsl(${i / maxPick * 360},80%,60%)`;
    ctx.fillRect(margin + xShift + i * binWidth, histY + histHeight - h, binWidth * 0.8, h);
  }

  ctx.strokeStyle = 'white';
  ctx.beginPath();
  ctx.moveTo(margin + xShift, histY + histHeight);
  ctx.lineTo(width - margin + xShift, histY + histHeight);
  ctx.moveTo(margin + xShift, histY + histHeight);
  ctx.lineTo(margin + xShift, histY);
  ctx.stroke();
}

let animationId = null;

function animate() {
  if (trialIndex < nTrials) {
    if (nTrials <= 10) {
      if (collected.size < nPokemon) {
        pickPokemon(); drawBase();
        setTimeout(() => { animationId = requestAnimationFrame(animate); }, 300);
      } else {
        allTrials.push(picks);
        trialIndex++; picks = 0; collected = new Set();
        setTimeout(() => { animationId = requestAnimationFrame(animate); }, 300);
      }
    } else {
      for (let t = 0; t < nTrials; t++) {
        let trialSet = new Set(), trialPicks = 0;
        while (trialSet.size < nPokemon) { trialSet.add(Math.floor(Math.random() * nPokemon)); trialPicks++; }
        allTrials.push(trialPicks);
        trialSet.forEach(c => pokemonCounts[c]++);
      }
      trialIndex = nTrials;
      picks = 0; collected = new Set();
      drawBase();
    }
  }
}

document.getElementById('startBtn').onclick = function () { init(); animate(); };
document.getElementById('resetBtn').onclick = function () { init(); };
</script>
</body>
</html>
